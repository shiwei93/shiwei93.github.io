<html>
  <head>
    <meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>二十七</title>
<meta name="description" content="浪花有意千重雪，桃李无言一队春" />
<link rel="shortcut icon" href="https://shiwei93.github.io/favicon.ico?v=1577975002481">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.10.0/katex.min.css">
<link href="https://cdn.remixicon.com/releases/v1.3.1/remixicon.css" rel="stylesheet">
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Droid+Serif:400,700">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.7.2/animate.min.css">

<link rel="stylesheet" href="https://shiwei93.github.io/styles/main.css">
<link rel="alternate" type="application/atom+xml" title="二十七 - Atom Feed" href="https://shiwei93.github.io/atom.xml">



  </head>
  <body>
    <div id="app" class="main px-4 flex flex-col lg:flex-row">
      <div id="sidebar" class="sidebar-wrapper lg:static lg:w-1/4">
  <div class="lg:sticky top-0">
    <div class="sidebar-content">
      <div class="flex lg:block p-4 lg:px-0 items-center fixed lg:static lg:block top-0 right-0 left-0 bg-white z-50">
        <i class="remixicon-menu-2-line lg:mt-4 text-2xl cursor-pointer animated fadeIn" onclick="openMenu()"></i>
        <a href="https://shiwei93.github.io">
          <img class="animated fadeInLeft avatar rounded-lg mx-4 lg:mt-32 lg:mx-0 mt-0 lg:w-24 lg:h-24 w-12 w-12" src="https://shiwei93.github.io/images/avatar.png?v=1577975002481" alt="">
        </a>
        <h1 class="animated fadeInLeft lg:text-4xl font-extrabold lg:mt-8 mt-0 text-xl" style="animation-delay: 0.2s">二十七</h1>
      </div>
      
        <div class="animated fadeInLeft" style="animation-delay: 0.4s">
          <p class="my-4 text-gray-600 font-light hidden lg:block">
            文章目录
          </p>
          <div class="toc-container hidden lg:block">
            <ul class="markdownIt-TOC">
<li>
<ul>
<li><a href="#useful-extension">Useful Extension</a>
<ul>
<li><a href="#notification-name-userdefaults-%E7%9A%84-key">Notification Name &amp; UserDefaults 的 Key</a></li>
<li><a href="#uipangesturerecognizer-%E7%9A%84%E6%96%B9%E5%90%91">UIPanGestureRecognizer 的方向</a></li>
<li><a href="#nslayoutconstraint-multiplier">NSLayoutConstraint Multiplier</a>
<ul>
<li><a href="#%E5%9C%BA%E6%99%AF%E9%87%8D%E7%8E%B0">场景重现</a></li>
<li><a href="#%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88">解决方案</a></li>
</ul>
</li>
<li><a href="#%E4%BF%9D%E7%95%99%E5%88%9D%E5%A7%8B%E5%8C%96%E6%96%B9%E6%B3%95">保留初始化方法</a></li>
<li><a href="#remove-all-arranged-subviews-in-uistackview">Remove all arranged subviews in UIStackView</a></li>
</ul>
</li>
<li><a href="#%E4%B8%80%E7%82%B9%E6%80%9D%E8%80%83">一点思考</a>
<ul>
<li><a href="#%E5%A6%82%E4%BD%95%E8%AF%84%E5%88%A4%E4%B8%80%E4%B8%AA-extension-%E6%98%AF%E5%BF%85%E8%A6%81%E7%9A%84%E4%B8%94%E6%9C%89%E4%BB%B7%E5%80%BC%E7%9A%84">如何评判一个 Extension 是必要的，且有价值的</a></li>
<li><a href="#%E7%BC%96%E5%86%99-extension-%E9%9C%80%E8%A6%81%E9%81%B5%E5%BE%AA%E5%93%AA%E4%BA%9B%E5%8E%9F%E5%88%99">编写 Extension 需要遵循哪些原则</a></li>
</ul>
</li>
</ul>
</li>
</ul>

          </div>
        </div>
      
    </div>
  </div>
</div>

<div class="menu-container">
  <i class="remixicon-arrow-left-line text-2xl cursor-pointer animated fadeIn close-menu-btn" onclick="closeMenu()"></i>
  <div>
    
      
        <a href="/" class="menu" style="animation-delay: 0s">
          首页
        </a>
      
    
      
        <a href="/archives" class="menu" style="animation-delay: 0.2s">
          归档
        </a>
      
    
      
        <a href="/tags" class="menu" style="animation-delay: 0.4s">
          标签
        </a>
      
    
      
        <a href="/post/about" class="menu" style="animation-delay: 0.6000000000000001s">
          关于
        </a>
      
    
  </div>
  <div class="site-footer">
    <div class="py-4 text-gray-700">Powered by <a href="https://github.com/getgridea/gridea" target="_blank">Gridea</a></div>
    <a class="rss" href="https://shiwei93.github.io/atom.xml" target="_blank">RSS</a>
  </div>
</div>
<div class="mask" onclick="closeMenu()">
</div>
      <div class="content-wrapper py-32 lg:p-8 lg:w-3/4 post-detail animated fadeIn">
        <h1 class="text-3xl font-bold lg:mt-16">Swift Extension</h1>
        <div class="text-sm text-gray-700 lg:my-8">
          2018-08-16 / 9 min read
        </div>
        
          <img class="post-feature-image rounded-lg mx-auto my-4" src="https://shiwei93.github.io/post-images/swift-extension.jpg" alt="">
        
        <div class="post-content yue">
          <p>前些日子准备周会关于 <strong>Swift Extension</strong> 的分享时，翻看自己之前写过的 Extension 时。发现有些在可扩展性，以及易用性上并不尽如人意，这也让我在周会讨论中加入了如下议题。</p>
<ul>
<li>如何评判一个 Extension 是必要的，且有价值的</li>
<li>编写 Extension 需要遵循哪些原则</li>
</ul>
<!-- more -->
<p>接下来，先罗列一下我认为比较有用的 Extension。对于问题的讨论，在最后写一些我自己的看法。</p>
<h2 id="useful-extension">Useful Extension</h2>
<h3 id="notification-name-userdefaults-的-key">Notification Name &amp; UserDefaults 的 Key</h3>
<p>以前发送通知时，都是一个简单的字符串，大都使用复制粘贴来处理。有了些许统一常量观念之后，可能会想到如下的代码</p>
<pre><code class="language-swift">struct NotificationNames {
    static let finishedLoading = &quot;FinishedLoading&quot;
}
</code></pre>
<p>Swift 3 之后，通知的名称又变成了 <code>Notification.Name(_: )</code> 的形式，于是又需要修改每一个 struct。好在 Swift 基础库中提供了 <code>RawRepresentable</code> 这样的 protocol，用一句话概括这个 protocol 的作用就是</p>
<blockquote>
<p>遵循这个协议的类型可以用来表示另一个类型</p>
</blockquote>
<p>um... 可能这句话有点语病，具体使用还是看下面的实现吧。</p>
<pre><code class="language-swift">protocol NotificationName {
    var name: Notification.Name { get }
}

extension RawRepresentable where RawValue == String, Self: NotificationName {
    var name: Notification.Name {
        get {
            return Notification.Name(self.rawValue.lowercased())
        }
    }
}
</code></pre>
<p>代码本身也比较容易理解就不多做说明了，来看下具体怎么定义 Notification.Name。此时只需要创建一个 enum 来统一管理通知名就可以了，具体如下：</p>
<pre><code class="language-swift">enum Notifications: String, NotificationName {
    case finishedLoading
}
</code></pre>
<p>接下来，就可以在通知的新建和发送通知时，用 <code>Notifications.finishedLoading.name</code> 代替之前并不足够优雅的形式了。</p>
<p>有了 <code>RawRepresentable</code> 在 Notification.Name 中的使用范例，举一反三可以想到在 UserDefaults 中也能够使用来定义 Key 值。由于实现几乎一致，就不多做赘述，直接上代码。</p>
<pre><code class="language-swift">protocol UserDefaultKeysType {
    var key: String { get }
}

extension RawRepresentable where RawValue == String, Self: UserDefaultKeysType {
    var key: String {
        get {
            return self.rawValue.lowercased()
        }
    }
}

enum UserDefaultKeys: String, UserDefaultKeysType {
    case xxx
}

// 使用起来就是
UserDefaults.standard.set(true, forKey: UserDefaultKeys.xxx.key)
</code></pre>
<h3 id="uipangesturerecognizer-的方向">UIPanGestureRecognizer 的方向</h3>
<p>判断一个 UIPanGestureRecognizer 的滑动方向，可能需要下面两步。</p>
<ul>
<li>Step One
<ul>
<li>调用 <code>velocity(in view: UIView?) -&gt; CGPoint</code> 方法获取速度</li>
</ul>
</li>
<li>Step Two
<ul>
<li>比较速度 x/y 轴绝对值的大小关系，判断 x 轴还是 y 轴的移动</li>
<li>判断上一个结果值与零的大小关系，判断向左向右还是向上向下</li>
</ul>
</li>
</ul>
<p>每一次判断都要重复做以上两个步骤，太过繁琐。通过 Extension 来做一些简化操作。</p>
<p>首先，在方向这个概念上，使用统一的 <strong>Driection</strong>，能够见文知意。</p>
<pre><code class="language-swift">public struct Direction: OptionSet {
    public var rawValue: UInt8
    
    public init(rawValue: UInt8) {
        self.rawValue = rawValue
    }
    
    static let none = Direction(rawValue: 0)
    static let up = Direction(rawValue: 1 &lt;&lt; 0)
    static let down = Direction(rawValue: 1 &lt;&lt; 1)
    static let left = Direction(rawValue: 1 &lt;&lt; 2)
    static let right = Direction(rawValue: 1 &lt;&lt; 3)
}
</code></pre>
<p>接下来，就是将上述的两个步骤实现写到 <code>UIPanGestureRecognizer</code> 的 Extension 里。</p>
<pre><code class="language-swift">extension UIPanGestureRecognizer {
    private func direction(byVelocity velocity: CGFloat, greater: Direction, lower: Direction) -&gt; Direction {
        if velocity == 0 { return [] }
        return velocity &gt; 0 ? greater : lower
    }
    
    public func direction(in view: UIView) -&gt; Direction {
        let velocity = self.velocity(in: view)
        let y = direction(byVelocity: velocity.y, greater: .down, lower: .up)
        let x = direction(byVelocity: velocity.x, greater: .right, lower: .left)
        return fabs(velocity.x) &gt; fabs(velocity.y) ? x : y
    }
}
</code></pre>
<h3 id="nslayoutconstraint-multiplier">NSLayoutConstraint Multiplier</h3>
<h4 id="场景重现">场景重现</h4>
<center><img src='https://res.cloudinary.com/dxe4zc5py/image/upload/v1534469383/Jietu20180817-092812.png'></center>
<p>用 Xib 实现了一个简单的表示进度的视图，这里通过改变上层 view 和 下层 view 的宽度比例关系，实现显示进度。当把这个约束，<strong>拖到</strong> 代码文件中后，想用 <code>processConstraint.multiplier = progress</code> 改变比例时，编译器会告诉我们</p>
<p>{% colorquote danger %}<br>
Cannot assign to property: 'multiplier' is a get-only property<br>
{% endcolorquote %}</p>
<h4 id="解决方案">解决方案</h4>
<p>那么，既然 <strong>multiplier</strong> 无法直接修改，那也只能，先去除这个约束，再添加新的约束了。写过官方代码实现约束的应该都有无法言说的痛，那通过一个 Extension 把操作统一起来。</p>
<pre><code class="language-swift">extension NSLayoutConstraint {
    func setMultiplier(_ multiplier: CGFloat) -&gt; NSLayoutConstraint {
        guard let firstItem= firstItem else { fatalError(&quot;约束不存在&quot;) }
        NSLayoutConstraint.deactivate([self])
        let new = NSLayoutConstraint(
            item: firstItem,
            attribute: firstAttribute,
            relatedBy: relation,
            toItem: secondItem,
            attribute: secondAttribute,
            multiplier: multiplier,
            constant: constant)
        
        new.priority = priority
        new.shouldBeArchived = shouldBeArchived
        new.identifier = identifier
        
        NSLayoutConstraint.activate([new])
        return new
    }
}
</code></pre>
<h3 id="保留初始化方法">保留初始化方法</h3>
<p>严格说来这不能算作一个有用的 Extension，只能说是一个使用 Extension 的小技巧。</p>
<pre><code class="language-swift">struct Person {
    let name: String
    let age: Int
}
</code></pre>
<p>此时初始化一个 Person，会有 <code>init(name: String, age: Int)</code> 方法。接下来修改一下 Person 结构体，添加一个自定义的初始化的方法。</p>
<pre><code class="language-swift">struct Person {
    let name: String
    let age: Int
    
    init(withDictionary dictionary: [String: Any]) {
        ...
    }
}
</code></pre>
<p>此时，再去初始化 Person 时，就会发现只有一个 <code>init(withDictionary dictionary: [String: Any])</code> 初始化方法了。如果我们希望在自定义初始化方法后，仍然保留原来的默认初始化方法，该怎么做呢？答案就是，添加一个 Extension，将自定义的初始化方法写到 Extension 里。</p>
<pre><code class="language-swift">struct Person {
    let name: String
    let age: Int
}

extension Person {
    init(withDictionary dictionary: [String: Any]) {
        ...
    }
}
</code></pre>
<p>接下来，初始化 Person 时，就会保留默认的初始化方法了。</p>
<h3 id="remove-all-arranged-subviews-in-uistackview">Remove all arranged subviews in UIStackView</h3>
<p>使用 UIStackView 时，如果需要移除 arranged view，UIKit 提供了 <code>func removeArrangedSubview(_ view: UIView)</code>，每次只能移除一个。查阅<a href="https://developer.apple.com/documentation/uikit/uistackview/1616235-removearrangedsubview">官方文档</a>　发现 Discussion</p>
<blockquote>
<p><strong>Discussion</strong><br>
This method removes the provided view from the stack’s <a href="https://developer.apple.com/documentation/uikit/uistackview/1616232-arrangedsubviews">arrangedSubviews</a> array. The view’s position and size will no longer be managed by the stack view. However, this method does not remove the provided view from the stack’s <a href="https://developer.apple.com/documentation/uikit/uiview/1622614-subviews">subviews</a> array; therefore, the view is still displayed as part of the view hierarchy.</p>
<p>To prevent the view from appearing on screen after calling the stack’s removeArrangedSubview: method, explicitly remove the view from the subviews array by calling the view’s <a href="https://developer.apple.com/documentation/uikit/uiview/1622421-removefromsuperview">removeFromSuperview()</a> method, or set the view’s <a href="https://developer.apple.com/documentation/uikit/uiview/1622585-ishidden">isHidden</a> property to true.</p>
</blockquote>
<p>um...<code>removeArrangedSubview(_ view: UIView)</code> 不会把想要移除的 view 从 stackView 的 subviews 数组中移除。也就是说，之后仍然需要调用 <code>removeFromSuperView()</code> 来移除它。</p>
<pre><code class="language-swift">extension UIStackView {
    public func removeAllArrangedSubviews() {
        let removedSubviews = arrangedSubviews.reduce([]) { (allSubviews, subview) -&gt; [UIView] in
            self.removeArrangedSubview(subview)
            return allSubviews + [subview]
        }
        
        NSLayoutConstraint.deactivate(removedSubviews.flatMap { $0.constraints }) // 移除约束
        removedSubviews.forEach { $0.removeFromSuperview() }
    }
}
</code></pre>
<h2 id="一点思考">一点思考</h2>
<p>文章开头，提出了两个问题，下面是一些自己的思考。</p>
<ul>
<li>如何评判一个 Extension 是必要的，且有价值的</li>
<li>编写 Extension 需要遵循哪些原则</li>
</ul>
<h3 id="如何评判一个-extension-是必要的且有价值的">如何评判一个 Extension 是必要的，且有价值的</h3>
<p>如果说为了解决一个问题，特意写一个 Extension 是万万不可取的。首先需要考虑使用的场景，将要写在 Extension 里的代码是否具有重用价值。例如之前曾写过这样的代码</p>
<pre><code class="language-swift">extension String {
    public var isNotEmpty: Bool {
        get {
            return !self.isEmpty
        }
    }
}
</code></pre>
<p>乍一看，似乎解决了能够让 <code>if !string.isEmpty {...}</code> 变为 <code>if string.isNotEmpty {...}</code> 显得更为直观。但仔细推敲一下，真的有必要嘛？如果 <code>!</code> 非操作都能让程序猿觉得不直观，那还有什么样的代码才能算是直观的呢？</p>
<p>其次，就是通用性的问题了，正如有道面试题</p>
<blockquote>
<p>两个变量值互换</p>
</blockquote>
<p>很多的优秀答案随便搜一搜，就能知道了。这个问题引申到这里，就是需要考虑 Extension 的通用性。例如之前做视频播放时，需要将 TimeInterval 转换为 <strong>&quot;00:00&quot;</strong> 格式的字符串。</p>
<pre><code class="language-swift">extension TimeInterval {
    public var mediaForamt: String {
        get {
            if isNaN { return &quot;00:00&quot; }
            let minutes = Int(self / 60)
            let seconds = Int(self.truncatingRemainder(dividingBy: 60))
            return String(format: &quot;%02d:%02d&quot;, minutes, seconds)
        }
    }
}
</code></pre>
<p>这样的 Extension 不应当被标记为 public，只提供了 <strong>&quot;00:00&quot;</strong> 格式，无法扩展。需求如果变更为需要 <strong>&quot;00:00:00&quot;</strong> 带上了小时，只能再写一个变量。</p>
<h3 id="编写-extension-需要遵循哪些原则">编写 Extension 需要遵循哪些原则</h3>
<p>综上，一个好的 Extension 应当遵循如下原则</p>
<ol>
<li>
<p>通用性</p>
<p>例如 Extension 中方法参数不应当写成固定类型，如果写成了固定类型，此方法也不能公开出去。因为，这不是一个通用的方法，使用时会带来诸多限制。</p>
</li>
<li>
<p>可扩展性</p>
<p>典型的正则表达式，每次新增需求需要添加新的正则表达式的时候，应当能够通过最简单的方式实现正则匹配。而不应当每次有新的正则时，都像下面一样新增变量。</p>
<pre><code class="language-Swift">extension String {
    public var isPhoneNumber: Bool { ... } 
}
</code></pre>
<p>可以用 <code>RawRepresentable</code> 来统一管理正则表达式，使用时，参数传递想要匹配的正则就可以了。</p>
</li>
<li>
<p>易用性</p>
<p>简单易用就不多做说明了，写 Extension 不就是为了方便使用嘛？</p>
</li>
</ol>

        </div>

        
          <a class="animated fadeInUp p-2 items-center text-sm text-gray-700 border hover:bg-gray-300 leading-none rounded-full flex lg:inline-flex m-4 " href="https://shiwei93.github.io/tcA3M53tk">
            <span class="flex-auto">iOS</span>
          </a>
        


        <div class="flex justify-between py-8">
          
            <div class="prev-post">
              <a href="https://shiwei93.github.io/swift-algorithm-hash-table">
                <h3 class="post-title">
                  <i class="remixicon-arrow-left-line"></i>
                  【译】Swift 算法 - 哈希表
                </h3>
              </a>
            </div>
          

          
            <div class="next-post">
              <a href="https://shiwei93.github.io/linkblock-iOS">
                <h3 class="post-title">
                  Swift &amp; Objective-C 中的链式调用
                  <i class="remixicon-arrow-right-line"></i>
                </h3>
              </a>
            </div>
          
        </div>

        

      </div>
    </div>

    <script src="https://shiwei93.github.io/media/prism.js"></script>  
<script>

Prism.highlightAll()

let mainNavLinks = document.querySelectorAll(".markdownIt-TOC a");

// This should probably be throttled.
// Especially because it triggers during smooth scrolling.
// https://lodash.com/docs/4.17.10#throttle
// You could do like...
// window.addEventListener("scroll", () => {
//    _.throttle(doThatStuff, 100);
// });
// Only not doing it here to keep this Pen dependency-free.

window.addEventListener("scroll", event => {
  let fromTop = window.scrollY;

  mainNavLinks.forEach((link, index) => {
    let section = document.getElementById(decodeURI(link.hash).substring(1));
    let nextSection = null
    if (mainNavLinks[index + 1]) {
      nextSection = document.getElementById(decodeURI(mainNavLinks[index + 1].hash).substring(1));
    }
    if (section.offsetTop <= fromTop) {
      if (nextSection) {
        if (nextSection.offsetTop > fromTop) {
          link.classList.add("current");
        } else {
          link.classList.remove("current");    
        }
      } else {
        link.classList.add("current");
      }
    } else {
      link.classList.remove("current");
    }
  });
});


document.addEventListener("DOMContentLoaded", function() {
  var lazyImages = [].slice.call(document.querySelectorAll(".post-feature-image.lazy"));

  if ("IntersectionObserver" in window) {
    let lazyImageObserver = new IntersectionObserver(function(entries, observer) {
      entries.forEach(function(entry) {
        if (entry.isIntersecting) {
          let lazyImage = entry.target
          lazyImage.style.backgroundImage = `url(${lazyImage.dataset.bg})`
          lazyImage.classList.remove("lazy")
          lazyImageObserver.unobserve(lazyImage)
        }
      });
    });

    lazyImages.forEach(function(lazyImage) {
      lazyImageObserver.observe(lazyImage)
    })
  } else {
    // Possibly fall back to a more compatible method here
  }
});

const menuContainer = document.querySelector('.menu-container')
const menus = document.querySelectorAll('.menu-container .menu')
const mask = document.querySelector('.mask')
const contentWrapper = document.querySelector('.content-wrapper')
const latestArticle = document.querySelector('.latest-article')
const readMore = document.querySelector('.read-more')
const indexPage = document.querySelector('.index-page')

const isHome = location.pathname === '/'
if (latestArticle) {
  latestArticle.style.display = isHome ? 'block' : 'none'
  readMore.style.display = isHome ? 'block' : 'none'
  indexPage.style.display = isHome ? 'none' : 'block'
}

const openMenu = () => {
  menuContainer.classList.add('open')
  menus.forEach(menu => {
    menu.classList.add('animated', 'fadeInLeft')
  })
  mask.classList.add('open')
  contentWrapper.classList.add('is-second')
}

const closeMenu = () => {
  menuContainer.classList.remove('open')
  menus.forEach(menu => {
    menu.classList.remove('animated', 'fadeInLeft')
  })
  mask.classList.remove('open')
  contentWrapper.classList.remove('is-second')
}
</script>
  
  </body>
</html>
