<html>
  <head>
    <meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>二十七</title>
<meta name="description" content="浪花有意千重雪，桃李无言一队春" />
<link rel="shortcut icon" href="https://shiwei93.github.io/favicon.ico?v=1578401360701">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.10.0/katex.min.css">
<link href="https://cdn.remixicon.com/releases/v1.3.1/remixicon.css" rel="stylesheet">
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Droid+Serif:400,700">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.7.2/animate.min.css">

<link rel="stylesheet" href="https://shiwei93.github.io/styles/main.css">
<link rel="alternate" type="application/atom+xml" title="二十七 - Atom Feed" href="https://shiwei93.github.io/atom.xml">



  </head>
  <body>
    <div id="app" class="main px-4 flex flex-col lg:flex-row">
      <div id="sidebar" class="sidebar-wrapper lg:static lg:w-1/4">
  <div class="lg:sticky top-0">
    <div class="sidebar-content">
      <div class="flex lg:block p-4 lg:px-0 items-center fixed lg:static lg:block top-0 right-0 left-0 bg-white z-50">
        <i class="remixicon-menu-2-line lg:mt-4 text-2xl cursor-pointer animated fadeIn" onclick="openMenu()"></i>
        <a href="https://shiwei93.github.io">
          <img class="animated fadeInLeft avatar rounded-lg mx-4 lg:mt-32 lg:mx-0 mt-0 lg:w-24 lg:h-24 w-12 w-12" src="https://shiwei93.github.io/images/avatar.png?v=1578401360701" alt="">
        </a>
        <h1 class="animated fadeInLeft lg:text-4xl font-extrabold lg:mt-8 mt-0 text-xl" style="animation-delay: 0.2s">二十七</h1>
      </div>
      
        <div class="animated fadeInLeft" style="animation-delay: 0.4s">
          <p class="my-4 text-gray-600 font-light hidden lg:block">
            文章目录
          </p>
          <div class="toc-container hidden lg:block">
            <ul class="markdownIt-TOC">
<li>
<ul>
<li>
<ul>
<li><a href="#%E4%BB%8E%E5%93%AA%E9%87%8C%E5%BC%80%E5%A7%8B">从哪里开始？</a></li>
<li><a href="#1-%E6%9F%A5%E7%9C%8B%E5%8F%98%E9%87%8F%E5%80%BC%E5%92%8C%E7%8A%B6%E6%80%81">1. 查看变量值和状态</a></li>
<li><a href="#2-%E8%8E%B7%E5%8F%96-app-%E6%95%B4%E4%BD%93%E7%8A%B6%E6%80%81%E4%B8%8E%E7%89%B9%E5%AE%9A%E8%AF%AD%E8%A8%80%E6%8C%87%E4%BB%A4">2. 获取 App 整体状态与特定语言指令</a></li>
<li><a href="#%E6%8E%A7%E5%88%B6-app-%E7%9A%84%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B">控制 App 的执行流程</a></li>
<li><a href="#%E5%85%B6%E4%BB%96">其他</a></li>
</ul>
</li>
</ul>
</li>
</ul>

          </div>
        </div>
      
    </div>
  </div>
</div>

<div class="menu-container">
  <i class="remixicon-arrow-left-line text-2xl cursor-pointer animated fadeIn close-menu-btn" onclick="closeMenu()"></i>
  <div>
    
      
        <a href="/" class="menu" style="animation-delay: 0s">
          首页
        </a>
      
    
      
        <a href="/archives" class="menu" style="animation-delay: 0.2s">
          归档
        </a>
      
    
      
        <a href="/tags" class="menu" style="animation-delay: 0.4s">
          标签
        </a>
      
    
      
        <a href="/post/about" class="menu" style="animation-delay: 0.6000000000000001s">
          关于
        </a>
      
    
  </div>
  <div class="site-footer">
    <div class="py-4 text-gray-700">Powered by <a href="https://github.com/getgridea/gridea" target="_blank">Gridea</a></div>
    <a class="rss" href="https://shiwei93.github.io/atom.xml" target="_blank">RSS</a>
  </div>
</div>
<div class="mask" onclick="closeMenu()">
</div>
      <div class="content-wrapper py-32 lg:p-8 lg:w-3/4 post-detail animated fadeIn">
        <h1 class="text-3xl font-bold lg:mt-16">【译】使用 LLDB 调试 Swift 代码</h1>
        <div class="text-sm text-gray-700 lg:my-8">
          2018-09-30 / 15 min read
        </div>
        
          <img class="post-feature-image rounded-lg mx-auto my-4" src="https://shiwei93.github.io/post-images/debugging-swift-code-with-lldb.jpg" alt="">
        
        <div class="post-content yue">
          <p><a href="https://medium.com/flawless-app-stories/debugging-swift-code-with-lldb-b30c5cf2fd49">原文地址</a></p>
<p>作为工程师，我们会花费 70% 的时间来调试。剩下的 20% 用于思考架构和与同事交流，最后的 10% 才是真正用于编码的时间。</p>
<!-- more -->
<blockquote>
<p>调试就像是在犯罪电影中同时扮演侦探和嫌疑人。</p>
<p>-- <a href="https://twitter.com/fortes"><u><em>Filipe Fortes</em></u></a> <em>via Twitter</em></p>
</blockquote>
<p>因此，如何让 70% 的调试时间尽可能的愉快，就显得及其重要。LLDB 因此应运而生。Xcode 的 UI 调试工具展示了所有有用的调试信息，而不用敲任何 LLDB 指令。然而，控制台在我们日常工作中仍然扮演了重要的角色，下面介绍一些笔者在日常调试工作中经常使用的 LLDB 小技巧。</p>
<h3 id="从哪里开始">从哪里开始？</h3>
<p>LLDB 是一款包含了许多有用指令的强大工具。笔者不可能详细的介绍每一条指令，所以这里会列举一些最常用的命令。下面是本文的计划</p>
<ol>
<li>
<p>查看变量值：<code>expression</code>，<code>e</code>，<code>print</code>，<code>po</code>，<code>p</code></p>
</li>
<li>
<p>获取 App 整体状态与特定语言指令：<code>bugreport</code>，<code>frame</code>，<code>language</code></p>
</li>
<li>
<p>控制 App 的执行流程：<code>process</code>，<code>breakpoint</code>，<code>thread</code>，<code>watchpoint</code></p>
</li>
<li>
<p>其他：<code>command</code>，<code>platform</code>，<code>gui</code></p>
</li>
</ol>
<p>原作者也准备了一份包含描述和例子的 LLDB 指令图。按需自取</p>
<figure data-type="image" tabindex="1"><img src="https://cdn-images-1.medium.com/max/1600/1*bDt6SNjK1QN9Tfz-roasDg.png" alt="" loading="lazy"></figure>
<p><a href="https://www.dropbox.com/s/9sv67e7f2repbpb/lldb-commands-map.png?dl=0">Download full size version with this link — <u>https://www.dropbox.com/s/9sv67e7f2repbpb/lldb-commands-map.png?dl=0</u></a></p>
<h3 id="1-查看变量值和状态">1. 查看变量值和状态</h3>
<p>指令： <code>expression</code>，<code>e</code>，<code>print</code>，<code>po</code>，<code>p</code></p>
<figure data-type="image" tabindex="2"><img src="https://cdn-images-1.medium.com/max/2000/1*HcuIHN3WucfxG2Mk80wldw.png" alt="" loading="lazy"></figure>
<p>调试器最基本的功能就是查看和修改变量的值，这也是 <code>expression</code> 或 <code>e</code> 的功能。</p>
<p>假设你正在调试一个 <code>valueOfLifeWithoutSumOf()</code> 函数，函数把两个数值相加再与 42 做差。</p>
<figure data-type="image" tabindex="3"><img src="https://cdn-images-1.medium.com/max/1600/1*ZRG-coIMk9udSc4edkMO6w.png" alt="" loading="lazy"></figure>
<p>也假设你一直得到错误的结果并且无从得知原因何在。因此为了找到问题所在，你尝试了如下的方法：</p>
<figure data-type="image" tabindex="4"><img src="https://cdn-images-1.medium.com/max/1600/1*LOFplcSqjYiO2BAjPi--4A.png" alt="" loading="lazy"></figure>
<p>最佳的方式，其实是使用 LLDB 而不是在代码中直接修改值。首先，在你觉得有问题的代码处，设置一个断点，接着运行 app。</p>
<p>在 LLDB 中，通过调用如下指令，来打印特定的变量值</p>
<pre><code>(lldb) e &lt;variable&gt;
</code></pre>
<p>另外，用来执行表达式计算的指令也及其相似</p>
<pre><code>(lldb) e &lt;expression&gt;
</code></pre>
<figure data-type="image" tabindex="5"><img src="https://cdn-images-1.medium.com/max/1600/1*MCBw_pKgO2N5uPZKYmS0fQ.png" alt="lldb" loading="lazy"></figure>
<pre><code>(lldb) e sum 
(Int) $R0 = 6 // 可以使用 $R0 在当前调试会话中调用这个变量
(lldb) e sum = 4 // 修改 sum 变量
(lldb) e sum 
(Int) $R2 = 4 // sum 变量的值在当前的调试中都会是 '4'
</code></pre>
<p><code>expression</code> 指令也提供了一些标记。为了区分标记和表达式，LLDB 使用 <code>--</code> 来做区分：</p>
<pre><code>(lldb) expression &lt;标记&gt; -- &lt;variable&gt;
</code></pre>
<p><code>expression</code> 指令有接近 30 种不同的标记。在终端中可以通过如下指令来获取全部的介绍文档</p>
<pre><code>&gt; lldb
&gt; (lldb) help # 查阅所有指令文档
&gt; (lldb) help expression # 查阅所有 expression 的子指令用法
</code></pre>
<p>下面介绍一些常用的 <code>expression</code> 标记：</p>
<ul>
<li><code>-D &lt;count&gt;</code> (<code>--depth &lt;count&gt;</code>) 设置集合类型的最大递归深度 (默认为无穷大)</li>
<li><code>-O</code> (<code>--object-description</code>) 如果可能的话，使用显示特定语言描述的 API</li>
<li><code>-T</code> (<code>--show-types</code>) 显示打印的值的类型</li>
<li><code>-f &lt;format&gt;</code> (<code>--format &lt;format&gt;</code>) 指定显示的格式</li>
<li><code>-i &lt;boolean&gt;</code> (<code>--ignore-breakpoints &lt;boolean&gt;</code>) 是否在运行 <code>expression</code> 时忽略断点</li>
</ul>
<p>这里假设有个名为 <code>logger</code> 的对象。该对象包含一些 string 和结构体作为属性。例如，你只想查看最上层的属性。只要是有 <code>-D</code> 标签指定遍历深度</p>
<pre><code>(lldb) e -D 1 -- logger

(LLDB_Debugger_Exploration.Logger) $R5 = 0x0000608000087e90 {
  currentClassName = &quot;ViewController&quot;
  debuggerStruct ={...}
}
</code></pre>
<p>默认的 LLDB 会无限递归的查看对象内部所有对象的描述：</p>
<pre><code>(lldb) e -- logger


(LLDB_Debugger_Exploration.Logger) $R6 = 0x0000608000087e90 {
  currentClassName = &quot;ViewController&quot;
  debuggerStruct = (methodName = &quot;name&quot;, lineNumber = 2, commandCounter = 23)
}
</code></pre>
<p>也可以通过 <code>e -O --</code> 或者简单的 <code>po</code> 来查看对象的描述</p>
<pre><code>(lldb) po logger
&lt;Logger: 0x608000087e90&gt;
</code></pre>
<p>为了便于阅读，需要为自定义的类遵循 <code>CustomStringConvertible</code> 并实现 <code>var description: String { return ...}</code> 属性。<code>po</code> 才会返回便于阅读的描述信息。</p>
<figure data-type="image" tabindex="6"><img src="https://cdn-images-1.medium.com/max/2000/1*v1JRHrSQmGIOkEUiQ5CZXA.png" alt="print" loading="lazy"></figure>
<p><code>print &lt;expression/variable&gt;</code> 与 <code>expression -- &lt;expression/variable&gt;</code> 功能一致。区别在于 <code>print</code> 指令不接受任何标签或额外的参数。</p>
<h3 id="2-获取-app-整体状态与特定语言指令">2. 获取 App 整体状态与特定语言指令</h3>
<p><code>bugreport</code>，<code>frame</code>，<code>language</code></p>
<figure data-type="image" tabindex="7"><img src="https://cdn-images-1.medium.com/max/2000/1*1OpRvgpxYDjA5ZeEpbh55Q.png" alt="bugreport" loading="lazy"></figure>
<p>LLDB 提供了 <code>bugreport</code> 来生成当前 app 状态的完整日志。当你遇到问题，并且想要稍后处理的时候，这个指令相当有用。为了存储发生错误时的 app 状态，可以使用 <code>bugreport</code> 生成日志。</p>
<pre><code>(lldb) bugreport unwind --outfile &lt;path to output file&gt;
</code></pre>
<p>最终的日志如下截图</p>
<figure data-type="image" tabindex="8"><img src="https://cdn-images-1.medium.com/max/2000/1*ziOW_lKhI6cBgGHl204kDg.png" alt="bugreport 的输出范例" loading="lazy"></figure>
<figure data-type="image" tabindex="9"><img src="https://cdn-images-1.medium.com/max/2000/1*05j2Rp0t2hWAHsCW3tReqg.png" alt="frame" loading="lazy"></figure>
<p><code>frame</code> 可以用于快速查看当前线程中的堆栈信息</p>
<figure data-type="image" tabindex="10"><img src="https://cdn-images-1.medium.com/max/1600/1*nAyd2l2m679XpH_In968YQ.png" alt="例子" loading="lazy"></figure>
<p>用如下指令快速获取堆栈信息</p>
<pre><code>(lldb) frame info

frame #0: 0x000000010bbe4b4d LLDB-Debugger-Exploration`ViewController.valueOfLifeWithoutSumOf(a=2, b=2, self=0x00007fa0c1406900) -&gt; Int at ViewController.swift:96
</code></pre>
<p>下文中的断点管理部分，这部分信息将十分有用。</p>
<figure data-type="image" tabindex="11"><img src="https://cdn-images-1.medium.com/max/2000/1*uLXBPbMvpDGU3Y9ElPQPsA.png" alt="language" loading="lazy"></figure>
<p>LLDB 有用于 C++，Objective-C，Swift 以及 RenderScript 的指令。这里只讨论 Swift 的相关指令   <code>demangle</code> 和 <code>refcount</code>。</p>
<p>Swift 在编译时，为了避免 namespace 的问题，会将类型名做特殊处理，<code>demangle</code> 的作用就是恢复这一问题。如果想要深入了解这一部分，可以查阅 WWDC14 的 session -- <a href="https://developer.apple.com/videos/play/wwdc2014/410/">“Advanced Swift Debugging in LLDB”</a>。</p>
<p><code>refcount</code> 用于显示指定对象的引用计数。</p>
<pre><code>(lldb) language swift refcount logger

refcount data: (strong = 4, weak = 0)
</code></pre>
<p>在调试一些内存泄漏问题时，将会十分有用。</p>
<h3 id="控制-app-的执行流程">控制 App 的执行流程</h3>
<p><code>precess</code>，<code>breakpoint</code>，<code>thread</code></p>
<p>接下来介绍的 LLDB 指令能够自动完成许多日常重复的 Debug 工作，最终大大提高我们的 debug 的流程。</p>
<figure data-type="image" tabindex="12"><img src="https://cdn-images-1.medium.com/max/1000/1*mLGvusUvwDjWnuRGIaM6zw.png" alt="process" loading="lazy"></figure>
<p>通过 <code>process</code> 指令，能够控制 debug 流程，不过由于 Xcode 会在断点处自动停下，这里就不再赘述，如果需要了解如何在终端中到达指定的调试点，可以查阅 Apple <a href="https://developer.apple.com/library/archive/documentation/IDEs/Conceptual/gdb_to_lldb_transition_guide/document/lldb-terminal-workflow-tutorial.html">官方文档</a></p>
<p>通过 <code>process status</code> 能够查看当前调试器等待的位置</p>
<pre><code>(lldb) process status

Process 27408 stopped
* thread #1, queue = 'com.apple.main-thread', stop reason = step over
frame #0: 0x000000010bbe4889 LLDB-Debugger-Exploration`ViewController.viewDidLoad(self=0x00007fa0c1406900) -&gt; () at ViewController.swift:69
66
67           let a = 2, b = 2
68           let result = valueOfLifeWithoutSumOf(a, and: b)
-&gt; 69           print(result)
70
71
72
</code></pre>
<p>通过如下命令可以继续项目运行，直到下一个断点出现</p>
<pre><code>(lldb) process continue

(lldb) c // Or just type &quot;c&quot; which is the same as previous command
</code></pre>
<p>在 Xcode 调试器的工具栏里也提供了按钮来继续运行</p>
<figure data-type="image" tabindex="13"><img src="https://cdn-images-1.medium.com/max/800/1*655uraZK-VpJeVu6T_yp1w.png" alt="Xcode continue" loading="lazy"></figure>
<figure data-type="image" tabindex="14"><img src="https://cdn-images-1.medium.com/max/1000/1*gv020i3Uihl0JCxg4D6FyQ.png" alt="breakpoint" loading="lazy"></figure>
<p><code>breakpoint</code> 指令允许我们在任意可能的地方操作断点。这里跳过见文知意的指令，例如：<code>breakpoint enable</code>，<code>breakpoint disable</code> 和 <code>breakpoint delete</code>。</p>
<p>首先，查看所有的断点，可以使用 <code>list</code> 指令</p>
<pre><code>(lldb) breakpoint list

Current breakpoints:
1: file = '/Users/Ahmed/Desktop/Recent/LLDB-Debugger-Exploration/LLDB-Debugger-Exploration/ViewController.swift', line = 95, exact_match = 0, locations = 1, resolved = 1, hit count = 1

1.1: where = LLDB-Debugger-Exploration`LLDB_Debugger_Exploration.ViewController.valueOfLifeWithoutSumOf (Swift.Int, and : Swift.Int) -&gt; Swift.Int + 27 at ViewController.swift:95, address = 0x0000000107f3eb3b, resolved, hit count = 1

2: file = '/Users/Ahmed/Desktop/Recent/LLDB-Debugger-Exploration/LLDB-Debugger-Exploration/ViewController.swift', line = 60, exact_match = 0, locations = 1, resolved = 1, hit count = 1

2.1: where = LLDB-Debugger-Exploration`LLDB_Debugger_Exploration.ViewController.viewDidLoad () -&gt; () + 521 at ViewController.swift:60, address = 0x0000000107f3e609, resolved, hit count = 1
</code></pre>
<p>开始的数字代表了断点的唯一标识符，可以用来快速查找任何指定的断点。通过如下指令，可以设置新的断点</p>
<pre><code>(lldb) breakpoint set -f ViewController.swift -l 96

Breakpoint 3: where = LLDB-Debugger-Exploration`LLDB_Debugger_Exploration.ViewController.valueOfLifeWithoutSumOf (Swift.Int, and : Swift.Int) -&gt; Swift.Int + 45 at ViewController.swift:96, address = 0x0000000107f3eb4d
</code></pre>
<p><code>-f</code> 代表了你想要放置断点的源文件。<code>-l</code> 是新断点的行数。当然，使用 <code>b</code> 指令能够简化设置断点的指令：</p>
<pre><code>(lldb) b ViewController.swift:96
</code></pre>
<p>也可以通过特定的正则表达式来设置断点（例如函数名）。</p>
<pre><code>(lldb) breakpoint set --func-regex valueOfLifeWithoutSumOf

(lldb) b -r valueOfLifeWithoutSumOf // 简单版本
</code></pre>
<p>有时需要设置一个只响应一次的断点，在响应之后自动删除该断点。下面的指令实现了这样的功能</p>
<pre><code>(lldb) breakpoint set --one-shot true -f ViewController.swift -l 90

(lldb) br s -o true -f ViewController.swift -l 91 // Shorter version of the command above
</code></pre>
<p>接下来是最有趣的部分--自动化断点。可以在断点响应之后可以立即执行一些特定的动作。你是否在调试时使用 <code>print</code> 打印你想要查看的值？下面有更好的方式。</p>
<p>利用 <code>breakpoint command</code>，你可以设置在断点命中时立即执行一些设定的指令。甚至可以设置不中断程序执行的“不可见”断点。当然，这些“不可见”断点也会中断程序运行但无法注意到，其实不过是在指令集之后添加了 <code>continue</code> 指令。</p>
<pre><code>(lldb) b ViewController.swift:96 // 首先添加一个断点

Breakpoint 2: where = LLDB-Debugger-Exploration`LLDB_Debugger_Exploration.ViewController.valueOfLifeWithoutSumOf (Swift.Int, and : Swift.Int) -&gt; Swift.Int + 45 at ViewController.swift:96, address = 0x000000010c555b4d

(lldb) breakpoint command add 2 // 设置一些指令 

Enter your debugger command(s).  Type 'DONE' to end.
&gt; p sum // 打印 &quot;sum&quot; 的值
&gt; p a + b // 计算 a + b
&gt; DONE
</code></pre>
<p>可以使用下面的指令来查看添加的指令是否正确</p>
<pre><code>(lldb) breakpoint command list 2

Breakpoint 2:
Breakpoint commands:
p sum
p a + b
</code></pre>
<p>当这个断点再次被命中时，就可以在控制台得到如下输出</p>
<pre><code>Process 36612 resuming
p sum
(Int) $R0 = 6

p a + b
(Int) $R1 = 4
</code></pre>
<p>这正是我们想要的。可以在指令最后添加 <code>continue</code> 指令，这样就不会在这个断点处停下来。</p>
<pre><code>(lldb) breakpoint command add 2 // 设置一些指令 

Enter your debugger command(s).  Type 'DONE' to end.
&gt; p sum // 打印 &quot;sum&quot; 的值
&gt; p a + b // 计算 a + b
&gt; continue // 在断点命中后继续执行
&gt; DONE
</code></pre>
<p>因此结果应该是：</p>
<pre><code>p sum
(Int) $R0 = 6

p a + b
(Int) $R1 = 4

continue
Process 36863 resuming
Command #3 'continue' continued the target.
</code></pre>
<figure data-type="image" tabindex="15"><img src="https://cdn-images-1.medium.com/max/2000/1*Hd2VNOZsUZ2Lsmk_oznRig.png" alt="thread" loading="lazy"></figure>
<p>利用 <code>thread</code> 以及它的子命令，可以完全控制执行流程：<code>step-over</code>，<code>step-in</code>，<code>step-out</code> 以及 <code>continue</code>。这些指令也和 Xcode 调试器的工具栏上的流程控制按钮功能一致。</p>
<figure data-type="image" tabindex="16"><img src="https://cdn-images-1.medium.com/max/1600/1*_CILKjcJsdVco-hG9rDmhg.png" alt="flow control buttons" loading="lazy"></figure>
<p>上述的指令也有简写版本</p>
<pre><code>(lldb) thread step-over
(lldb) next // 与 &quot;thread step-over&quot; 相同
(lldb) n // 与 &quot;next&quot; 相同

(lldb) thread step-in
(lldb) step // 与 &quot;thread step-in&quot; 相同
(lldb) s // 与 &quot;step&quot; 相同
</code></pre>
<p>可以通过 <code>info</code> 指令来获取当前线程的信息</p>
<pre><code>(lldb) thread info 

thread #1: tid = 0x17de17, 0x0000000109429a90 LLDB-Debugger-Exploration`ViewController.sumOf(a=2, b=2, self=0x00007fe775507390) -&gt; Int at ViewController.swift:90, queue = 'com.apple.main-thread', stop reason = step in
</code></pre>
<p>通过 <code>list</code> 子命令，可以列举所有当前激活的线程信息</p>
<pre><code>(lldb) thread list

Process 50693 stopped

* thread #1: tid = 0x17de17, 0x0000000109429a90 LLDB-Debugger-Exploration`ViewController.sumOf(a=2, b=2, self=0x00007fe775507390) -&gt; Int at ViewController.swift:90, queue = 'com.apple.main-thread', stop reason = step in

  thread #2: tid = 0x17df4a, 0x000000010daa4dc6  libsystem_kernel.dylib`kevent_qos + 10, queue = 'com.apple.libdispatch-manager'
  
  thread #3: tid = 0x17df4b, 0x000000010daa444e libsystem_kernel.dylib`__workq_kernreturn + 10
  
  thread #5: tid = 0x17df4e, 0x000000010da9c34a libsystem_kernel.dylib`mach_msg_trap + 10, name = 'com.apple.uikit.eventfetch-thread'
</code></pre>
<h3 id="其他">其他</h3>
<p><code>command</code>，<code>platform</code>，<code>gui</code></p>
<figure data-type="image" tabindex="17"><img src="https://cdn-images-1.medium.com/max/2000/1*X9Dl7gaVB1elSpD8WycZGA.png" alt="command" loading="lazy"></figure>
<p>在 LLDB 中你可以发现一个用于管理其他命令的指令。听起来很诡异，但事实上缺是一个很有用的小工具。首先，它允许你从文件中执行一些 LLDB 命令。因此可以创建一个包含一些命令的文件，之后可以通过一条命令执行他们。下面是写入文件的命令：</p>
<pre><code>thread info // 显示当前线程信息
br list // 列举所有断点
</code></pre>
<p>执行命令后，结果如下：</p>
<pre><code>(lldb) command source /Users/Ahmed/Desktop/lldb-test-script

Executing commands in '/Users/Ahmed/Desktop/lldb-test-script'.

thread info
thread #1: tid = 0x17de17, 0x0000000109429a90 LLDB-Debugger-Exploration`ViewController.sumOf(a=2, b=2, self=0x00007fe775507390) -&gt; Int at ViewController.swift:90, queue = 'com.apple.main-thread', stop reason = step in

br list
Current breakpoints:
1: file = '/Users/Ahmed/Desktop/Recent/LLDB-Debugger-Exploration/LLDB-Debugger-Exploration/ViewController.swift', line = 60, exact_match = 0, locations = 1, resolved = 1, hit count = 0
1.1: where = LLDB-Debugger-Exploration`LLDB_Debugger_Exploration.ViewController.viewDidLoad () -&gt; () + 521 at ViewController.swift:60, address = 0x0000000109429609, resolved, hit count = 0
</code></pre>
<p>缺点就是无法传递参数到源文件中。</p>
<p>进阶的做法是使用 <code>script</code> 子命令。<code>script</code> 允许使用自定义的 Python 脚本（<code>add</code>，<code>delete</code>，<code>import</code> 和 <code>list</code>）。<code>script</code> 让真正意义上的自动化成为可能。可以参阅<a href="http://www.fabianguerra.com/ios/introduction-to-lldb-python-scripting/">指南</a>。简单的例子，创建一个脚本文件 <em>script.py</em> 并且通过 <em>print_hello()</em> 打印 &quot;Hello Debugger!&quot; 到控制台：</p>
<pre><code class="language-Python">import lldb

def print_hello(debugger, command, result, internal_dict):
	print &quot;Hello Debugger!&quot;
    
def __lldb_init_module(debugger, internal_dict):
	debugger.HandleCommand('command script add -f script.print_hello print_hello') // Handle script initialization and add command from this module
	print 'The &quot;print_hello&quot; python command has been installed and is ready for use.' // Print confirmation that everything works
</code></pre>
<p>之后需要导入 Python 模块，执行 script 命令：</p>
<pre><code>(lldb) command script import ~/Desktop/script.py

The &quot;print_hello&quot; python command has been installed and is ready for use.

(lldb) print_hello

Hello Debugger!
</code></pre>
<figure data-type="image" tabindex="18"><img src="https://cdn-images-1.medium.com/max/2000/1*6fRizbW5TQ02_DzHnUinzg.png" alt="platform" loading="lazy"></figure>
<p>可以通过 <code>status</code> 子命令来检查当前平台信息。<code>status</code> 会显示：SDK 路径，处理器架构，操作系统版本以及该 SDK 所有支持的设备列表。</p>
<pre><code>(lldb) platform status

Platform: ios-simulator
Triple: x86_64-apple-macosx
OS Version: 10.12.5 (16F73)
Kernel: Darwin Kernel Version 16.6.0: Fri Apr 14 16:21:16 PDT 2017; root:xnu-3789.60.24~6/RELEASE_X86_64
Hostname: 127.0.0.1
WorkingDir: /
SDK Path: &quot;/Applications/Xcode.app/Contents/Developer/Platforms/iPhoneSimulator.platform/Developer/SDKs/iPhoneSimulator.sdk&quot;

Available devices:
614F8701-3D93-4B43-AE86-46A42FEB905A: iPhone 4s
CD516CF7-2AE7-4127-92DF-F536FE56BA22: iPhone 5
0D76F30F-2332-4E0C-9F00-B86F009D59A3: iPhone 5s
3084003F-7626-462A-825B-193E6E5B9AA7: iPhone 6
...
</code></pre>
<figure data-type="image" tabindex="19"><img src="https://cdn-images-1.medium.com/max/2000/1*S914ih9-vrEoXKllCJpl0g.png" alt="gui" loading="lazy"></figure>
<p>虽然无法在 Xcode 中使用 LLDB 的 GUI 模式，不过可以在终端中使用。</p>
<pre><code>(lldb) gui
// 如果在 Xcode 中尝试执行 gui 命令，会得到如下错误
error: the gui command requires an interactive terminal.
</code></pre>
<figure data-type="image" tabindex="20"><img src="https://cdn-images-1.medium.com/max/1600/1*iN9X46pAI6cDv-ZL5v4L-w.png" alt="LLDB GUI 样式" loading="lazy"></figure>

        </div>

        
          <a class="animated fadeInUp p-2 items-center text-sm text-gray-700 border hover:bg-gray-300 leading-none rounded-full flex lg:inline-flex m-4 " href="https://shiwei93.github.io/tcA3M53tk">
            <span class="flex-auto">iOS</span>
          </a>
        


        <div class="flex justify-between py-8">
          
            <div class="prev-post">
              <a href="https://shiwei93.github.io/whats-new-in-swift-5-0">
                <h3 class="post-title">
                  <i class="remixicon-arrow-left-line"></i>
                  Swift 5.0 语言新特性
                </h3>
              </a>
            </div>
          

          
            <div class="next-post">
              <a href="https://shiwei93.github.io/swift-algorithm-hash-table">
                <h3 class="post-title">
                  【译】Swift 算法 - 哈希表
                  <i class="remixicon-arrow-right-line"></i>
                </h3>
              </a>
            </div>
          
        </div>

        

      </div>
    </div>

    <script src="https://shiwei93.github.io/media/prism.js"></script>  
<script>

Prism.highlightAll()

let mainNavLinks = document.querySelectorAll(".markdownIt-TOC a");

// This should probably be throttled.
// Especially because it triggers during smooth scrolling.
// https://lodash.com/docs/4.17.10#throttle
// You could do like...
// window.addEventListener("scroll", () => {
//    _.throttle(doThatStuff, 100);
// });
// Only not doing it here to keep this Pen dependency-free.

window.addEventListener("scroll", event => {
  let fromTop = window.scrollY;

  mainNavLinks.forEach((link, index) => {
    let section = document.getElementById(decodeURI(link.hash).substring(1));
    let nextSection = null
    if (mainNavLinks[index + 1]) {
      nextSection = document.getElementById(decodeURI(mainNavLinks[index + 1].hash).substring(1));
    }
    if (section.offsetTop <= fromTop) {
      if (nextSection) {
        if (nextSection.offsetTop > fromTop) {
          link.classList.add("current");
        } else {
          link.classList.remove("current");    
        }
      } else {
        link.classList.add("current");
      }
    } else {
      link.classList.remove("current");
    }
  });
});


document.addEventListener("DOMContentLoaded", function() {
  var lazyImages = [].slice.call(document.querySelectorAll(".post-feature-image.lazy"));

  if ("IntersectionObserver" in window) {
    let lazyImageObserver = new IntersectionObserver(function(entries, observer) {
      entries.forEach(function(entry) {
        if (entry.isIntersecting) {
          let lazyImage = entry.target
          lazyImage.style.backgroundImage = `url(${lazyImage.dataset.bg})`
          lazyImage.classList.remove("lazy")
          lazyImageObserver.unobserve(lazyImage)
        }
      });
    });

    lazyImages.forEach(function(lazyImage) {
      lazyImageObserver.observe(lazyImage)
    })
  } else {
    // Possibly fall back to a more compatible method here
  }
});

const menuContainer = document.querySelector('.menu-container')
const menus = document.querySelectorAll('.menu-container .menu')
const mask = document.querySelector('.mask')
const contentWrapper = document.querySelector('.content-wrapper')
const latestArticle = document.querySelector('.latest-article')
const readMore = document.querySelector('.read-more')
const indexPage = document.querySelector('.index-page')

const isHome = location.pathname === '/'
if (latestArticle) {
  latestArticle.style.display = isHome ? 'block' : 'none'
  readMore.style.display = isHome ? 'block' : 'none'
  indexPage.style.display = isHome ? 'none' : 'block'
}

const openMenu = () => {
  menuContainer.classList.add('open')
  menus.forEach(menu => {
    menu.classList.add('animated', 'fadeInLeft')
  })
  mask.classList.add('open')
  contentWrapper.classList.add('is-second')
}

const closeMenu = () => {
  menuContainer.classList.remove('open')
  menus.forEach(menu => {
    menu.classList.remove('animated', 'fadeInLeft')
  })
  mask.classList.remove('open')
  contentWrapper.classList.remove('is-second')
}
</script>
  
  </body>
</html>
