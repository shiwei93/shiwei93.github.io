<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://shiwei93.github.io</id>
    <title>二十七</title>
    <updated>2020-01-07T13:21:35.472Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://shiwei93.github.io"/>
    <link rel="self" href="https://shiwei93.github.io/atom.xml"/>
    <subtitle>浪花有意千重雪，桃李无言一队春</subtitle>
    <logo>https://shiwei93.github.io/images/avatar.png</logo>
    <icon>https://shiwei93.github.io/favicon.ico</icon>
    <rights>All rights reserved 2020, 二十七</rights>
    <entry>
        <title type="html"><![CDATA[LeetCode Daily Question 19]]></title>
        <id>https://shiwei93.github.io/leetcode-daily-Q-19</id>
        <link href="https://shiwei93.github.io/leetcode-daily-Q-19">
        </link>
        <updated>2020-01-07T12:54:51.000Z</updated>
        <content type="html"><![CDATA[<h2 id="题目">题目</h2>
<p><a href="https://leetcode-cn.com/problems/remove-nth-node-from-end-of-list/">19. Remove Nth Node From End of List</a><br>
给定一个链表，删除链表的倒数第 <em>n</em> 个节点，<strong>只遍历一次</strong>。</p>
<h2 id="思路">思路</h2>
<h3 id="初见">初见</h3>
<p>在不考虑只遍历一次的进阶条件下，使用两个指针，第一次遍历完整个链表取到链表中总计 <em>x</em> 个元素。第二次遍历到第 <em>x - n - 1</em> 个链表元素，假设为 node，执行 <code>node.next = node.next.next</code>，得解。</p>
<h3 id="再看">再看</h3>
<p>考虑只遍历一次这个条件，同样使用两个指针，但不能在一个指针遍历完成之后，再重新遍历，那么就需要两个指针同时工作。<br>
思路如下:</p>
<ol>
<li>定义两个指针 <em>fast</em> 和 <em>sow</em></li>
<li><em>fast</em> 指针先走 <em>n</em> 个元素</li>
<li>之后当 <em>fast</em> 的 next 节点不为 <em>nil</em> 时，<em>fast</em> 和 <em>slow</em> 同时往前</li>
<li>此时 <code>slow</code> 指针指向的就是倒数第 <em>n + 1</em> 的链表元素<br>
到这里，看似只要执行 <code>slow.next = slow.next.next</code> 就可以得到正确结果，然而在跑了测试用例之后发现，<code>[1, 2] / 2</code> 和 <code>[1] / 1</code> 的输入无法通过。如果当 <em>fast</em> 先走了 <em>n</em> 步时，恰好走到了最后一个节点，此时 <em>slow</em> 节点还没有移动，则说明链表中需要移除倒数第 <em>n</em> 个节点恰好是第一个节点。实现代码如下</li>
</ol>
<pre><code class="language-swift">func removeNthFromEnd(_ head: ListNode?, _ n: Int) -&gt; ListNode? {
    var fast = head, slow: ListNode? = nil, n: Int = n
    while let nd = fast {
        if n != 0 {
            fast = nd.next
            n -= 1
            continue
        }
        fast = fast?.next
        slow = slow == nil ? head : slow?.next
    }
    if slow == nil {
        return head?.next
    } else {
        slow?.next = slow?.next?.next
        return head
    }
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[中西文中间添加 Thin space U+2009]]></title>
        <id>https://shiwei93.github.io/thin-space</id>
        <link href="https://shiwei93.github.io/thin-space">
        </link>
        <updated>2019-06-20T02:30:29.000Z</updated>
        <content type="html"><![CDATA[<h2 id="前言">前言</h2>
<p>在平时的文字输入时，我总会在中文和英文，中文和数字中间添加一个普通空格 (U+0020)。在文本布局时不会显得那么拥挤，也一定程度上提升了阅读体验。前一段时间即刻 App 添加了一个中西文之前默认添加一个特殊空格的特性，体验之后发现，这样的宽度短于普通空格的<strong>特殊</strong>空格，即不会出现没有空格时过于拥挤的布局，也不会出现普通空格间距过大的问题。查阅了一些资料后，找到一篇关于 <a href="http://jkorpela.fi/chars/spaces.html">Sapce 的 Unicode 表</a>，想不到空格还有这么多的种类。</p>
<p>之前的开发工作中，出现过一些，长文本在 iOS 设备中不换行的 Bug，这个问题曾经困扰了我许久，后来无意中发现了一个叫 <em>NO-BREAK SPACE</em> 的空格，其 Unicode 为 <code>U+00A0</code>。在 App 中的表现就是，设置了 UILabel 的 numberOfLines 属性为 0 同时 breakMode 设置为 byWords，含有该空格的文本也不会换行，即使限制了 UILabel 的宽度，换行时仍然会拆开单词换行。</p>
<p>鉴于即刻 App 这个新需求带来的完美效果，着手简单实现一下。不过不知道即刻选用的空格种类，这里经过多次比较之后，我使用了 <code>U+2009</code>，被称为 <em>THIN SPACE</em> 的空格。</p>
<h2 id="实现">实现</h2>
<p>这个需求，我的第一反应就是使用正则来匹配给定字符串的如下情况</p>
<ul>
<li>中文+英文</li>
<li>英文+中文</li>
<li>中文+数字</li>
<li>数字+中文</li>
<li>中文+符号</li>
<li>符号+中文</li>
<li>忽略英文和数字的组合，即计量单位，如 10TB</li>
</ul>
<p>想到用 Swift 来实现正则表达式，就会有点头皮发麻。先不说 NSRegularExpression 的部分 API 中还带有 NSRange。就是正则表达式里面，还需要添加 / 转义符，就是一个噩梦，可读性大大降低。不过，好在 Swift 5 新增的 Raw String 可以完美解决这个问题。用到的所有正则表达式如下</p>
<pre><code class="language-swift">let chinese = #&quot;[\u2E80-\u2FFF\u31C0-\u31EF\u3300-\u4DBF\u4E00-\u9FFF\uF900-\uFAFF\uFE30-\uFE4F]&quot;# // 匹配中文

// 使用 tuple
// base 基础符号。单一符号，不成对
// open 与 close 成对出现的符号
let punc = (
    base: #&quot;[@&amp;=_\,\.\?\!\$\%\^\*\-\+\/]&quot;#,
    open: #&quot;[\(\[\{\'&quot;&lt;‘“]&quot;#,
    close: #&quot;[\)\]\}\'&quot;&gt;’”]&quot;#
)

// 拉丁字符。数字、字母等
let latin = #&quot;[A-Za-z0-9\u00C0-\u00FF\u0100-\u017F\u0180-\u024F\u1E00-\u1EFF]|\#(punc.base)&quot;#
</code></pre>
<p>由于需要匹配的情况有前后之分，下面用一个数组，将上述的正则表达式组合成两个完整的正则表达式。通过 compactMap 获取到最后的 NSRegularExpression 实例数组。</p>
<pre><code class="language-swift">let patterns = [
    #&quot;(\#(chinese))(\#(latin)|\#(punc.open))&quot;#,
    #&quot;(\#(latin)|\#(punc.close))(\#(chinese))&quot;#
].compactMap { try? NSRegularExpression(pattern: $0) }
</code></pre>
<p>最后，就可以通过 <code>stringByReplacingMatches(in:options:range:withTemplate:)</code> 方法，通过 template 替换原有的字符串了。</p>
<pre><code class="language-swift">let unicode = &quot;\u{2009}&quot;
patterns.forEach { (regex) in
    result = regex.stringByReplacingMatches(in: result, options: [], range: NSMakeRange(0, result.count), withTemplate: &quot;$1\(unicode)$2&quot;)
}
return result
</code></pre>
<p>下面的 Gif 比较了不添加空格、添加普通空格和 <code>U+2009</code> 空格的区别。</p>
<figure data-type="image" tabindex="1"><img src="https://res.cloudinary.com/dxe4zc5py/image/upload/v1561000680/Blog/2019-06-20_11.16.23.gif" alt="Gif" loading="lazy"></figure>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[JavaScript30 Day 25]]></title>
        <id>https://shiwei93.github.io/javascript30-day-25</id>
        <link href="https://shiwei93.github.io/javascript30-day-25">
        </link>
        <updated>2019-05-08T05:47:44.000Z</updated>
        <content type="html"><![CDATA[<p>今天的练习是关于 JavaScript 的事件流，下面做一些扩展与整理。</p>
<h2 id="事件流">事件流</h2>
<p><strong>事件流</strong>描述的是从页面中接收事件的顺序。IE 和 Netscape 团队提出了两种相反的事件流概念。IE 的事件流是事件冒泡流，而 Netscape 的事件流是事件捕获流。</p>
<h2 id="事件冒泡">事件冒泡</h2>
<p><strong>事件冒泡</strong>，即事件开始时由最具体的元素接收，然后逐层向上传播到较为不具体的节点。例如下面的代码</p>
<pre><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;title&gt;Title&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;div&gt;Click Me!&lt;/div&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p>如果单击页面中的 <code>&lt;div&gt;</code> 元素，那么这个 click 事件会按照如下顺序传播：</p>
<ol>
<li><code>&lt;div&gt;</code></li>
<li><code>&lt;body&gt;</code></li>
<li><code>&lt;html&gt;</code></li>
<li><code>document</code></li>
</ol>
<h2 id="事件捕获">事件捕获</h2>
<p><strong>事件捕获</strong>的思想是不太具体的节点应该更早的接收到事件，而具体的节点应该最后接收到事件。使用上文提到的例子，点击 <code>&lt;div&gt;</code> 元素时，事件的传播顺序就会变成</p>
<ol>
<li><code>document</code></li>
<li><code>&lt;html&gt;</code></li>
<li><code>&lt;body&gt;</code></li>
<li><code>&lt;div&gt;</code></li>
</ol>
<h2 id="dom-事件流">DOM 事件流</h2>
<p>“DOM2 级事件” 规定了事件流包括三个阶段</p>
<ol>
<li>捕获阶段 <code>CAPTURING_PHASE</code></li>
<li>目标阶段 <code>AT_TARGET</code></li>
<li>冒泡阶段 <code>BUBBLING_PHASE</code></li>
</ol>
<p>我们可以通过事件对象的 <code>eventPhase</code> 属性，得知事件处于哪个阶段。</p>
<p>DOM 事件在传播时，会从根节点开始往下传递到 <code>target</code>，若注册了事件监听，则监听器处于捕获阶段，为截获事件提供了机会。</p>
<p><code>target</code> 就是触发事件的具体对象，这时注册在 <code>target</code> 上的事件监听器处于目标阶段。</p>
<p>最后，事件再往上从 <code>target</code> 一路逆向传递到根节点，若注册了事件监听器，则监听器处于冒泡阶段，可以在这个阶段对事件作出响应。</p>
<p>以前面的 HTML 实例代码为例，单击 <code>&lt;div&gt;</code> 元素完整的事件流如下如所示</p>
<figure data-type="image" tabindex="1"><img src="https://res.cloudinary.com/dxe4zc5py/image/upload/v1557293001/Blog/281557292962_.pic.jpg" alt="图片来源于《JavaScript 高级程序设计》" loading="lazy"></figure>
<p>在 DOM 事件流中，实际的目标 <code>&lt;div&gt;</code> 在捕获阶段不会接收到事件。这意味着在捕获阶段，事件从 document 到 <code>&lt;html&gt;</code> 再到 <code>&lt;body&gt;</code> 后就停止了。下一个阶段是<strong>处于目标</strong>阶段，于是事件在 <code>&lt;div&gt;</code> 上发生，并在事件处理中被看成冒泡阶段的一部分。然后冒泡阶段发生，事件又传回了 document。</p>
<h2 id="事件处理">事件处理</h2>
<p>在今天的练习中，通过 <code>Event​Target​.add​Event​Listener()</code> 来添加事件监听。</p>
<h3 id="语法">语法</h3>
<blockquote>
<p><em>target.addEventListener(type, listener[, options]);</em></p>
<p><em>target.addEventListener(type, listener[, useCapture]);</em></p>
</blockquote>
<p>方法接收三个参数</p>
<blockquote>
<p><strong>type</strong></p>
<p>表示需要监听的<a href="https://developer.mozilla.org/zh-CN/docs/Web/Events">事件类型</a></p>
<p><strong>listener</strong></p>
<p>当所监听的事件类型触发时，接到一个事件通知对象。<code>listener</code> 必须是一个实现了 <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/EventListener"><code>EventListener</code></a> 接口的对象，或者是一个函数。</p>
<p><strong>options</strong> 可选</p>
<ol>
<li><code>capture</code> 默认为 false，即事件只会在冒泡阶段才会被执行。若为 true，即事件在捕获阶段就会被执行</li>
<li><code>once</code> 表示事件监听被添加后之后执行一次，默认为 false。如果被设置为 true，listener 在被调用后就会被移除。</li>
</ol>
<p><strong>useCapture</strong> 可选</p>
<p>默认为 false，表示注册事件是冒泡事件。若为 true，则表示注册事件为捕获事件。</p>
</blockquote>
<pre><code class="language-javascript">one.addEventListener('click', (e) =&gt; { 
            console.log(&quot;one capture mode&quot;, e.eventPhase);
}, true);
one.addEventListener('click', (e) =&gt; { 
   console.log(&quot;one bubble mode&quot;, e.eventPhase);
}, false);
two.addEventListener('click', (e) =&gt; {
   console.log(&quot;two capture mode 2&quot;);
}, true)
two.addEventListener('click', (e) =&gt; { console.log(&quot;two bubble mode&quot;, e.eventPhase); }, false);
three.addEventListener('click', (e) =&gt; { console.log(&quot;three capture mode&quot;, e.eventPhase); }, true);
three.addEventListener('click', (e) =&gt; { console.log(&quot;three bubble mode&quot;, e.eventPhase); }, false);
</code></pre>
<p>打印结果为</p>
<blockquote>
<p>one capture mode 1</p>
<p>two capture mode 1</p>
<p>three capture mode 2</p>
<p>three bubble mode 2</p>
<p>tow bubble mode 3</p>
<p>one bubble mode 3</p>
</blockquote>
<p>且打印顺序不和事件注册顺序有关。</p>
<h3 id="阻止事件冒泡">阻止事件冒泡</h3>
<pre><code class="language-javascript">two.addEventListener('click', (e) =&gt; { 
   console.log(&quot;two capture mode&quot;, e.eventPhase);
   e.stopPropagation();
}, true);
</code></pre>
<p>通过 <code>stopPropagation()</code> 可以阻止事件的冒泡，也阻止了事件的继续捕获。但无法阻止同一个元素其他绑定事件的执行。</p>
<p>使用 <code>stopImmediatePropagation()</code> 即阻止了事件的继续传递，也阻止了同一个元素的其他绑定事件的执行。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[JavaScript30 Day 19]]></title>
        <id>https://shiwei93.github.io/javascript30-day-19</id>
        <link href="https://shiwei93.github.io/javascript30-day-19">
        </link>
        <updated>2019-05-06T03:38:37.000Z</updated>
        <content type="html"><![CDATA[<p>今天的练习是使用摄像头，实时记录，并通过 canvas 实时绘制到画布中。</p>
<p>通过 <code>Media​Devices​.get​User​Media()</code> 方法，在通过授权之后，可以获取摄像头图像。具体代码如下</p>
<pre><code class="language-javascript">navigator.mediaDevices.getUserMedia({ video: true, audio: false})
    .then((videostream) =&gt; {
        console.log(videostream);
        video.srcObject = videostream;
        video.onloadedmetadata = function() { 
            video.play();
        };
    })
    .catch((error) =&gt; {
        console.error('OH, Don\'t have permission to use your local cam!', error);
    });
</code></pre>
<!--- more --->
<p>通过授权之后，返回一个 promise 对象，将返回值通过 <code>HTMLMedia​Element​.src​Object</code> 传入 video 中，可以在 video 标签中实时播放摄像头获取到的头像。<code>srcObject</code> 属性可以接收一个 <code>MediaStream</code>，一个 <code>MediaSource</code>，一个 <code>Blob</code> 或一个 <code>File</code> 对象。当资源文件的元数据加载完成时，就会调用 <code>Global​Event​Handlers​.onloadedmetadata</code> 参数，示例中传入了一个 function，用来开始播放视频。</p>
<p>给 video 标签添加 <code>'canplay'</code> 事件监听，<code>video.addEventListener('canplay', printToCanvas);</code>，当视频可以播放时，调用 <code>printToCanvas</code> 方法，绘制到 canvas 画布中。来看一下 <code>printToCanvas</code> 方法的代码实现</p>
<pre><code class="language-javascript">function printToCanvas() {
    const { videoWidth: width, videoHeight: height} = video;
    canvas.height = height;
    canvas.width = width;
    return setInterval(() =&gt; {
        ctx.drawImage(video, 0, 0, width, height);

        let imagedata = ctx.getImageData(0, 0, width, height);

        // imagedata = redEffect(imagedata);
        imagedata = rgbsplit(imagedata);
        // ctx.globalAlpha = 0.2;

        // imagedata = greenScreen(imagedata);

        ctx.putImageData(imagedata, 0, 0);
    }, 16);
}
</code></pre>
<p>首先通过解构赋值获取视频组件的宽高，<strong>注意</strong>，一定要设置 canvas 画布的宽高。接下来在 <code>setIntervale()</code> 中甚至重复时间的间隔为 16ms 即屏幕每次刷新的时间间隔，达到绘制摄像头每一帧图像的目的。</p>
<ol>
<li><code>ctx.drawImage()</code> 将视频流绘制到 canvas 中</li>
<li><code>ctx.getImageData()</code> 返回一个 <code>ImageData</code> 对象，用来描述 canvas 区域隐含的像素数据，这个区域通过矩形表示，起始点为 (sx, sy)、宽为 sw、高为 sh。<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/CanvasRenderingContext2D/getImageData">文档</a></li>
<li><code>ctx.putImageData()</code> 是 Canvas 2D API 将数据从已有的 <code>ImageData</code> 对象绘制到位图的方法。 如果提供了一个绘制过的矩形，则只绘制该矩形的像素。此方法不受画布转换矩阵的影响。<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/CanvasRenderingContext2D/putImageData">文档</a></li>
</ol>
<h2 id="拍照实现">拍照实现</h2>
<pre><code class="language-javascript">function takePhoto() {
    snap.currentTime = 0;
    snap.play();

    let data = canvas.toDataURL('image/jpeg');
    let link = document.createElement('a');
    link.href = data;
    link.setAttribute('download', 'handsome');
    link.innerHTML = `&lt;img src=${data} alt=handsome&gt;`;
    strip.insertBefore(link, strip.firstChild);
}
</code></pre>
<p>通过将 <code>HTMLCanvas​Element​.toDataURL()</code> 方法，获取当前 canvas 画布中的图像数据地址，接着新建一个 <code>a</code> 标签，并将其 href 属性设置为获取到的 canvas 画布图像数据的 URL。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[JavaScript30 Day 17]]></title>
        <id>https://shiwei93.github.io/javascript30-day-17</id>
        <link href="https://shiwei93.github.io/javascript30-day-17">
        </link>
        <updated>2019-05-04T01:05:19.000Z</updated>
        <content type="html"><![CDATA[<p>今天的练习是对数组的排序练习，特别的是需要去除字符串开头的 <strong>a an the</strong> 之后进行排序。</p>
<p>去除 <strong>a an the</strong> 的操作放到了一个 function 里，代码如下</p>
<pre><code class="language-javascript">function strip(str) {
    return str.replace(/^(a |an |the )/i, '').trim();
}
</code></pre>
<p><code>String.prototype.replace()</code> 接收两个参数，第一个参数可以是一个 <em>正则表达式</em> 或者 <em>待替换的子字符串</em>，第二个参数为 <em>新字符串</em> 或者 <em>函数</em>，返回替换后的新的字符串。</p>
<p>通过 <code>Array.prototype.sort()</code> 排序后，通过 map 方法，转换为 HTML 代码字符串，插入 HTML 代码中。</p>
]]></content>
    </entry>
</feed>