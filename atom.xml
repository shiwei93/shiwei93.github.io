<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://shiwei93.github.io</id>
    <title>二十七</title>
    <updated>2020-01-02T13:49:32.253Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://shiwei93.github.io"/>
    <link rel="self" href="https://shiwei93.github.io/atom.xml"/>
    <subtitle>浪花有意千重雪，桃李无言一队春</subtitle>
    <logo>https://shiwei93.github.io/images/avatar.png</logo>
    <icon>https://shiwei93.github.io/favicon.ico</icon>
    <rights>All rights reserved 2020, 二十七</rights>
    <entry>
        <title type="html"><![CDATA[中西文中间添加 Thin space U+2009]]></title>
        <id>https://shiwei93.github.io/post/thin-space</id>
        <link href="https://shiwei93.github.io/post/thin-space">
        </link>
        <updated>2019-06-20T02:30:29.000Z</updated>
        <content type="html"><![CDATA[<h2 id="前言">前言</h2>
<p>在平时的文字输入时，我总会在中文和英文，中文和数字中间添加一个普通空格 (U+0020)。在文本布局时不会显得那么拥挤，也一定程度上提升了阅读体验。前一段时间即刻 App 添加了一个中西文之前默认添加一个特殊空格的特性，体验之后发现，这样的宽度短于普通空格的<strong>特殊</strong>空格，即不会出现没有空格时过于拥挤的布局，也不会出现普通空格间距过大的问题。查阅了一些资料后，找到一篇关于 <a href="http://jkorpela.fi/chars/spaces.html">Sapce 的 Unicode 表</a>，想不到空格还有这么多的种类。</p>
<p>之前的开发工作中，出现过一些，长文本在 iOS 设备中不换行的 Bug，这个问题曾经困扰了我许久，后来无意中发现了一个叫 <em>NO-BREAK SPACE</em> 的空格，其 Unicode 为 <code>U+00A0</code>。在 App 中的表现就是，设置了 UILabel 的 numberOfLines 属性为 0 同时 breakMode 设置为 byWords，含有该空格的文本也不会换行，即使限制了 UILabel 的宽度，换行时仍然会拆开单词换行。</p>
<p>鉴于即刻 App 这个新需求带来的完美效果，着手简单实现一下。不过不知道即刻选用的空格种类，这里经过多次比较之后，我使用了 <code>U+2009</code>，被称为 <em>THIN SPACE</em> 的空格。</p>
<h2 id="实现">实现</h2>
<p>这个需求，我的第一反应就是使用正则来匹配给定字符串的如下情况</p>
<ul>
<li>中文+英文</li>
<li>英文+中文</li>
<li>中文+数字</li>
<li>数字+中文</li>
<li>中文+符号</li>
<li>符号+中文</li>
<li>忽略英文和数字的组合，即计量单位，如 10TB</li>
</ul>
<p>想到用 Swift 来实现正则表达式，就会有点头皮发麻。先不说 NSRegularExpression 的部分 API 中还带有 NSRange。就是正则表达式里面，还需要添加 / 转义符，就是一个噩梦，可读性大大降低。不过，好在 Swift 5 新增的 Raw String 可以完美解决这个问题。用到的所有正则表达式如下</p>
<pre><code class="language-swift">let chinese = #&quot;[\u2E80-\u2FFF\u31C0-\u31EF\u3300-\u4DBF\u4E00-\u9FFF\uF900-\uFAFF\uFE30-\uFE4F]&quot;# // 匹配中文

// 使用 tuple
// base 基础符号。单一符号，不成对
// open 与 close 成对出现的符号
let punc = (
    base: #&quot;[@&amp;=_\,\.\?\!\$\%\^\*\-\+\/]&quot;#,
    open: #&quot;[\(\[\{\'&quot;&lt;‘“]&quot;#,
    close: #&quot;[\)\]\}\'&quot;&gt;’”]&quot;#
)

// 拉丁字符。数字、字母等
let latin = #&quot;[A-Za-z0-9\u00C0-\u00FF\u0100-\u017F\u0180-\u024F\u1E00-\u1EFF]|\#(punc.base)&quot;#
</code></pre>
<p>由于需要匹配的情况有前后之分，下面用一个数组，将上述的正则表达式组合成两个完整的正则表达式。通过 compactMap 获取到最后的 NSRegularExpression 实例数组。</p>
<pre><code class="language-swift">let patterns = [
    #&quot;(\#(chinese))(\#(latin)|\#(punc.open))&quot;#,
    #&quot;(\#(latin)|\#(punc.close))(\#(chinese))&quot;#
].compactMap { try? NSRegularExpression(pattern: $0) }
</code></pre>
<p>最后，就可以通过 <code>stringByReplacingMatches(in:options:range:withTemplate:)</code> 方法，通过 template 替换原有的字符串了。</p>
<pre><code class="language-swift">let unicode = &quot;\u{2009}&quot;
patterns.forEach { (regex) in
    result = regex.stringByReplacingMatches(in: result, options: [], range: NSMakeRange(0, result.count), withTemplate: &quot;$1\(unicode)$2&quot;)
}
return result
</code></pre>
<p>下面的 Gif 比较了不添加空格、添加普通空格和 <code>U+2009</code> 空格的区别。</p>
<figure data-type="image" tabindex="1"><img src="https://res.cloudinary.com/dxe4zc5py/image/upload/v1561000680/Blog/2019-06-20_11.16.23.gif" alt="Gif" loading="lazy"></figure>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[JavaScript30 Day 25]]></title>
        <id>https://shiwei93.github.io/post/javascript30-day-25</id>
        <link href="https://shiwei93.github.io/post/javascript30-day-25">
        </link>
        <updated>2019-05-08T05:47:44.000Z</updated>
        <content type="html"><![CDATA[<p>今天的练习是关于 JavaScript 的事件流，下面做一些扩展与整理。</p>
<h2 id="事件流">事件流</h2>
<p><strong>事件流</strong>描述的是从页面中接收事件的顺序。IE 和 Netscape 团队提出了两种相反的事件流概念。IE 的事件流是事件冒泡流，而 Netscape 的事件流是事件捕获流。</p>
<h2 id="事件冒泡">事件冒泡</h2>
<p><strong>事件冒泡</strong>，即事件开始时由最具体的元素接收，然后逐层向上传播到较为不具体的节点。例如下面的代码</p>
<pre><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;title&gt;Title&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;div&gt;Click Me!&lt;/div&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p>如果单击页面中的 <code>&lt;div&gt;</code> 元素，那么这个 click 事件会按照如下顺序传播：</p>
<ol>
<li><code>&lt;div&gt;</code></li>
<li><code>&lt;body&gt;</code></li>
<li><code>&lt;html&gt;</code></li>
<li><code>document</code></li>
</ol>
<h2 id="事件捕获">事件捕获</h2>
<p><strong>事件捕获</strong>的思想是不太具体的节点应该更早的接收到事件，而具体的节点应该最后接收到事件。使用上文提到的例子，点击 <code>&lt;div&gt;</code> 元素时，事件的传播顺序就会变成</p>
<ol>
<li><code>document</code></li>
<li><code>&lt;html&gt;</code></li>
<li><code>&lt;body&gt;</code></li>
<li><code>&lt;div&gt;</code></li>
</ol>
<h2 id="dom-事件流">DOM 事件流</h2>
<p>“DOM2 级事件” 规定了事件流包括三个阶段</p>
<ol>
<li>捕获阶段 <code>CAPTURING_PHASE</code></li>
<li>目标阶段 <code>AT_TARGET</code></li>
<li>冒泡阶段 <code>BUBBLING_PHASE</code></li>
</ol>
<p>我们可以通过事件对象的 <code>eventPhase</code> 属性，得知事件处于哪个阶段。</p>
<p>DOM 事件在传播时，会从根节点开始往下传递到 <code>target</code>，若注册了事件监听，则监听器处于捕获阶段，为截获事件提供了机会。</p>
<p><code>target</code> 就是触发事件的具体对象，这时注册在 <code>target</code> 上的事件监听器处于目标阶段。</p>
<p>最后，事件再往上从 <code>target</code> 一路逆向传递到根节点，若注册了事件监听器，则监听器处于冒泡阶段，可以在这个阶段对事件作出响应。</p>
<p>以前面的 HTML 实例代码为例，单击 <code>&lt;div&gt;</code> 元素完整的事件流如下如所示</p>
<figure data-type="image" tabindex="1"><img src="https://res.cloudinary.com/dxe4zc5py/image/upload/v1557293001/Blog/281557292962_.pic.jpg" alt="图片来源于《JavaScript 高级程序设计》" loading="lazy"></figure>
<p>在 DOM 事件流中，实际的目标 <code>&lt;div&gt;</code> 在捕获阶段不会接收到事件。这意味着在捕获阶段，事件从 document 到 <code>&lt;html&gt;</code> 再到 <code>&lt;body&gt;</code> 后就停止了。下一个阶段是<strong>处于目标</strong>阶段，于是事件在 <code>&lt;div&gt;</code> 上发生，并在事件处理中被看成冒泡阶段的一部分。然后冒泡阶段发生，事件又传回了 document。</p>
<h2 id="事件处理">事件处理</h2>
<p>在今天的练习中，通过 <code>Event​Target​.add​Event​Listener()</code> 来添加事件监听。</p>
<h3 id="语法">语法</h3>
<blockquote>
<p><em>target.addEventListener(type, listener[, options]);</em></p>
<p><em>target.addEventListener(type, listener[, useCapture]);</em></p>
</blockquote>
<p>方法接收三个参数</p>
<blockquote>
<p><strong>type</strong></p>
<p>表示需要监听的<a href="https://developer.mozilla.org/zh-CN/docs/Web/Events">事件类型</a></p>
<p><strong>listener</strong></p>
<p>当所监听的事件类型触发时，接到一个事件通知对象。<code>listener</code> 必须是一个实现了 <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/EventListener"><code>EventListener</code></a> 接口的对象，或者是一个函数。</p>
<p><strong>options</strong> 可选</p>
<ol>
<li><code>capture</code> 默认为 false，即事件只会在冒泡阶段才会被执行。若为 true，即事件在捕获阶段就会被执行</li>
<li><code>once</code> 表示事件监听被添加后之后执行一次，默认为 false。如果被设置为 true，listener 在被调用后就会被移除。</li>
</ol>
<p><strong>useCapture</strong> 可选</p>
<p>默认为 false，表示注册事件是冒泡事件。若为 true，则表示注册事件为捕获事件。</p>
</blockquote>
<pre><code class="language-javascript">one.addEventListener('click', (e) =&gt; { 
            console.log(&quot;one capture mode&quot;, e.eventPhase);
}, true);
one.addEventListener('click', (e) =&gt; { 
   console.log(&quot;one bubble mode&quot;, e.eventPhase);
}, false);
two.addEventListener('click', (e) =&gt; {
   console.log(&quot;two capture mode 2&quot;);
}, true)
two.addEventListener('click', (e) =&gt; { console.log(&quot;two bubble mode&quot;, e.eventPhase); }, false);
three.addEventListener('click', (e) =&gt; { console.log(&quot;three capture mode&quot;, e.eventPhase); }, true);
three.addEventListener('click', (e) =&gt; { console.log(&quot;three bubble mode&quot;, e.eventPhase); }, false);
</code></pre>
<p>打印结果为</p>
<blockquote>
<p>one capture mode 1</p>
<p>two capture mode 1</p>
<p>three capture mode 2</p>
<p>three bubble mode 2</p>
<p>tow bubble mode 3</p>
<p>one bubble mode 3</p>
</blockquote>
<p>且打印顺序不和事件注册顺序有关。</p>
<h3 id="阻止事件冒泡">阻止事件冒泡</h3>
<pre><code class="language-javascript">two.addEventListener('click', (e) =&gt; { 
   console.log(&quot;two capture mode&quot;, e.eventPhase);
   e.stopPropagation();
}, true);
</code></pre>
<p>通过 <code>stopPropagation()</code> 可以阻止事件的冒泡，也阻止了事件的继续捕获。但无法阻止同一个元素其他绑定事件的执行。</p>
<p>使用 <code>stopImmediatePropagation()</code> 即阻止了事件的继续传递，也阻止了同一个元素的其他绑定事件的执行。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[JavaScript30 Day 19]]></title>
        <id>https://shiwei93.github.io/post/javascript30-day-19</id>
        <link href="https://shiwei93.github.io/post/javascript30-day-19">
        </link>
        <updated>2019-05-06T03:38:37.000Z</updated>
        <content type="html"><![CDATA[<p>今天的练习是使用摄像头，实时记录，并通过 canvas 实时绘制到画布中。</p>
<p>通过 <code>Media​Devices​.get​User​Media()</code> 方法，在通过授权之后，可以获取摄像头图像。具体代码如下</p>
<pre><code class="language-javascript">navigator.mediaDevices.getUserMedia({ video: true, audio: false})
    .then((videostream) =&gt; {
        console.log(videostream);
        video.srcObject = videostream;
        video.onloadedmetadata = function() { 
            video.play();
        };
    })
    .catch((error) =&gt; {
        console.error('OH, Don\'t have permission to use your local cam!', error);
    });
</code></pre>
<!--- more --->
<p>通过授权之后，返回一个 promise 对象，将返回值通过 <code>HTMLMedia​Element​.src​Object</code> 传入 video 中，可以在 video 标签中实时播放摄像头获取到的头像。<code>srcObject</code> 属性可以接收一个 <code>MediaStream</code>，一个 <code>MediaSource</code>，一个 <code>Blob</code> 或一个 <code>File</code> 对象。当资源文件的元数据加载完成时，就会调用 <code>Global​Event​Handlers​.onloadedmetadata</code> 参数，示例中传入了一个 function，用来开始播放视频。</p>
<p>给 video 标签添加 <code>'canplay'</code> 事件监听，<code>video.addEventListener('canplay', printToCanvas);</code>，当视频可以播放时，调用 <code>printToCanvas</code> 方法，绘制到 canvas 画布中。来看一下 <code>printToCanvas</code> 方法的代码实现</p>
<pre><code class="language-javascript">function printToCanvas() {
    const { videoWidth: width, videoHeight: height} = video;
    canvas.height = height;
    canvas.width = width;
    return setInterval(() =&gt; {
        ctx.drawImage(video, 0, 0, width, height);

        let imagedata = ctx.getImageData(0, 0, width, height);

        // imagedata = redEffect(imagedata);
        imagedata = rgbsplit(imagedata);
        // ctx.globalAlpha = 0.2;

        // imagedata = greenScreen(imagedata);

        ctx.putImageData(imagedata, 0, 0);
    }, 16);
}
</code></pre>
<p>首先通过解构赋值获取视频组件的宽高，<strong>注意</strong>，一定要设置 canvas 画布的宽高。接下来在 <code>setIntervale()</code> 中甚至重复时间的间隔为 16ms 即屏幕每次刷新的时间间隔，达到绘制摄像头每一帧图像的目的。</p>
<ol>
<li><code>ctx.drawImage()</code> 将视频流绘制到 canvas 中</li>
<li><code>ctx.getImageData()</code> 返回一个 <code>ImageData</code> 对象，用来描述 canvas 区域隐含的像素数据，这个区域通过矩形表示，起始点为 (sx, sy)、宽为 sw、高为 sh。<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/CanvasRenderingContext2D/getImageData">文档</a></li>
<li><code>ctx.putImageData()</code> 是 Canvas 2D API 将数据从已有的 <code>ImageData</code> 对象绘制到位图的方法。 如果提供了一个绘制过的矩形，则只绘制该矩形的像素。此方法不受画布转换矩阵的影响。<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/CanvasRenderingContext2D/putImageData">文档</a></li>
</ol>
<h2 id="拍照实现">拍照实现</h2>
<pre><code class="language-javascript">function takePhoto() {
    snap.currentTime = 0;
    snap.play();

    let data = canvas.toDataURL('image/jpeg');
    let link = document.createElement('a');
    link.href = data;
    link.setAttribute('download', 'handsome');
    link.innerHTML = `&lt;img src=${data} alt=handsome&gt;`;
    strip.insertBefore(link, strip.firstChild);
}
</code></pre>
<p>通过将 <code>HTMLCanvas​Element​.toDataURL()</code> 方法，获取当前 canvas 画布中的图像数据地址，接着新建一个 <code>a</code> 标签，并将其 href 属性设置为获取到的 canvas 画布图像数据的 URL。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[JavaScript30 Day 17]]></title>
        <id>https://shiwei93.github.io/post/javascript30-day-17</id>
        <link href="https://shiwei93.github.io/post/javascript30-day-17">
        </link>
        <updated>2019-05-04T01:05:19.000Z</updated>
        <content type="html"><![CDATA[<p>今天的练习是对数组的排序练习，特别的是需要去除字符串开头的 <strong>a an the</strong> 之后进行排序。</p>
<p>去除 <strong>a an the</strong> 的操作放到了一个 function 里，代码如下</p>
<pre><code class="language-javascript">function strip(str) {
    return str.replace(/^(a |an |the )/i, '').trim();
}
</code></pre>
<p><code>String.prototype.replace()</code> 接收两个参数，第一个参数可以是一个 <em>正则表达式</em> 或者 <em>待替换的子字符串</em>，第二个参数为 <em>新字符串</em> 或者 <em>函数</em>，返回替换后的新的字符串。</p>
<p>通过 <code>Array.prototype.sort()</code> 排序后，通过 map 方法，转换为 HTML 代码字符串，插入 HTML 代码中。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[JavaScript30 Day 16]]></title>
        <id>https://shiwei93.github.io/post/javascript30-day-16</id>
        <link href="https://shiwei93.github.io/post/javascript30-day-16">
        </link>
        <updated>2019-05-03T05:07:33.000Z</updated>
        <content type="html"><![CDATA[<p><a href="https://github.com/shiwei93/JavaScript30/tree/master/16%20-%20CSS%20Text%20Shadow%20Mouse%20Move%20Effect">GitHub 地址</a></p>
<p>今天的练习实现了一个鼠标移动修改文字阴影的效果。通过添加 <code>'mousemove'</code> 监听鼠标移动事件，计算鼠标移动的距离与阴影偏移的关系，修改文字阴影样式即可。</p>
<!--- more --->
<p>代码实现如下</p>
<pre><code class="language-javascript">const hero = document.querySelector('.hero');
const text = hero.querySelector('h1');
const walk = 500; // 100px

function shadow(e) {
    const { offsetWidth: width, offsetHeight: height } = hero;
    let { offsetX: x, offsetY: y } = e;

    if (this !== e.target) {
        x += e.target.offsetLeft;
        y += y + e.target.offsetTop;
    }

    const xWalk = Math.round((x / width * walk) - (walk / 2));
    const yWalk = Math.round((y / height * walk) - (walk / 2));

    text.style.textShadow = `
        ${xWalk}px ${yWalk}px 0 rgba(255, 0, 255, 0.7),
        ${xWalk * -1}px ${yWalk}px 0 rgba(0, 255, 255, 0.7),
        ${yWalk}px ${xWalk * -1}px 0 rgba(0, 255, 0, 0.7),
        ${yWalk * -1}px ${xWalk}px 0 rgba(0, 0, 255, 0.7)
    `;
}

hero.addEventListener('mousemove', shadow);
</code></pre>
<p>实现代码中 <code>const { offsetWidth: width, offsetHeight: height } = hero;</code> 这样的实现，被称之为解构赋值，<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment">参考文档</a>。</p>
]]></content>
    </entry>
</feed>